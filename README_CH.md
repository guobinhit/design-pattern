> **注意**：如果你想要阅读英文版`README`, 请点击 [这里](https://github.com/guobinhit/design-pattern/blob/master/README.md). 

# 设计模式

详细介绍了设计模式，并给出了大量的 Java 示例。

![author](https://img.shields.io/badge/author-chariesgavin-blueviolet.svg)![last commit](https://img.shields.io/github/last-commit/guobinhit/design-pattern.svg)![issues](https://img.shields.io/github/issues/guobinhit/design-pattern.svg)![stars](https://img.shields.io/github/stars/guobinhit/design-pattern.svg)![forks](https://img.shields.io/github/forks/guobinhit/design-pattern.svg)![license](https://img.shields.io/github/license/guobinhit/design-pattern.svg)


## 索引

- [单例模式](#单例模式)
- [策略模式](#策略模式)
- [装饰模式](#装饰模式)
- [观察者模式](#观察者模式)




## 单例模式

单例模式是一种软件设计模式，它将类的实例化限制为一个对象。当只需要一个对象来协调整个系统的操作时，这很有用。这个概念有时被推广到只有一个对象存在时操作更高效的系统，或者将实例化限制为特定数量的对象的系统。这个术语来自于数学的单例概念。单例模式的实现必须：

- 确保只有一个单例类的实例存在；并且
- 提供对该实例的全局访问。

> 单例设计模式解决了以下问题：

- 如何确保一个类只有一个实例？
- 如何让一个类的唯一实例更容易访问？
- 如何让类控制它的实例化？
- 如何限制类的实例数量？

通常，这是通过：

- 将类的所有构造函数声明为私有；以及
- 提供一个静态方法，该方法返回对实例的引用。

实例通常存储为私有静态变量；实例是在初始化变量时，在首次调用静态方法之前的某个时刻创建的。


## 策略模式

策略模式（也称为政策模式）是一种行为软件设计模式，可以在运行时选择算法。策略模式

- 定义了一簇算法，
- 封装每个算法，并且
- 使算法在该簇中可以互换。

例如，对传入数据执行验证的类可以根据数据类型、数据源、用户选择或其他判别因素使用策略模式来选择验证算法。这些因素直到运行时才知道，可能需要执行完全不同的验证。与验证对象分开封装的验证算法（策略）可以被系统不同区域（甚至不同系统）的其他验证对象使用，而无需重复的代码。

> 策略模式解决了以下问题：

- 一个类如何使用不同的算法？
- 如何使用算法配置类？
- 如何在运行时选择和交换算法？


## 装饰模式

装饰模式（也称为`Wrapper`，与适配器模式共享的另一种命名）是一种设计模式，允许将行为静态或动态地添加到单个对象中，而不会影响来自同一类的其他对象的行为。装饰模式对于坚持“单一责任原则”通常很有用，因为它允许在具有独特关注区域的类之间划分功能。

> 装饰设计模式能解决什么问题？

- 职责应该在运行时动态地添加（或者删除）到对象。
- 应该为扩展功能提供一个灵活的子类化替代方法。


## 观察者模式

观察者模式是一种软件设计模式，在这种模式中，一个称为主题的对象维护其从属对象（称为观察者）的列表，并通过调用其方法，使其自动通知观察者更改其状态。

> 观察者设计模式解决了以下问题：

- 如何在不使对象紧密耦合的情况下，定义对象之间的一对多依赖关系？
- 如何确保当一个对象改变状态时，会自动更新（同步）开放数量的观察者对象？
- 一个对象如何通知一个开放数量的其他对象？


